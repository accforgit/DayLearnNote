### 最新手机号码正则（包括阿里的蚂蚁宝卡，腾讯的大王卡）
```js
/^(13[0-9]|14[579]|15([0-3]|[5-9])|16[6]|17[0135678]|18[0-9]|19[89])\d{8}$/.test(17689897656);
```

### 如何优雅的取随机字符串
```js
// 13位
Math.random().toString(16).substring(2)
// 11位
Math.random().toString(36).substring(2)
```

### 判断是否为整数

1. 最优雅
  `function isInteger(x) { return (x^0) === x; }`
2. 常用（`Math.round` 也可以换成 `Math.ceil Math.floor`）
  `function isInteger(x) { return Math.round(x) === x; }`
3. 稍微复杂一点
  `function isInteger(x) { return (typeof x === 'number') && (x % 1 === 0);`

### 判断是否 NaN

```js
// 依据 NaN 谁都不等于包括不等于自身的特性，即 NaN !== NaN：

function isNaN(value) { return value !== value }
```

### 取出一个数组中的最大值和最小值
```js
var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]
var maxInNumbers = Math.max.apply(Math, numbers)
// => 12205
var minInNumbers = Math.min.apply(Math, numbers)
// => -85411
```

### 使用 `js`获取兼容可用的 样式属性名

```js
const getsuitablePropertyName = (name) => {
  let allPrefix = ['', '-webkit-', '-o-', '-ms-']
  let len = allPrefix.length
  let allStyle = document.body.style

  for (let i = 0; i < len; i++) {
    if (allPrefix[i] + name in allStyle) {
      return allPrefix[i] + name
    }
  }
  return null
}

// 用法示例
let suitTransform = getsuitablePropertyName('transform')
console.log(suitTransform)
// -> transform
```

### 使用 `js` 获取 `translate`的浏览器合适写法
```js
const getTranslate = () => {
  let allPrefix = ['', '-webkit-', '-o-', '-ms-']
  let len = allPrefix.length
  let ele = document.createElement('div')
  let eleTransform = getsuitablePropertyName('transform')
  let realTranslate = null
  for (let i = 0; i < len; i++) {
    realTranslate = `${allPrefix[i]}translate(0px, 0px)`
    ele.style[eleTransform] = realTranslate
    if (ele.style[eleTransform] === realTranslate) {
      return `${allPrefix[i]}translate`
    }
  }
  return null
}
```

### 使用 `js` 获取 `transitionend`的浏览器合适写法

```js
const getTransitionend = () => {
  let allOptions = ['ontransitionend', 'onWebkitTransitionEnd', 'onMozTransitionEnd', 'onOTransitionEnd']
  let len = allOptions.length

  for (let i = 0; i < len; i++) {
    if (allOptions[i] in window) {
      return allOptions[i]
    }
  }
  return null
}
```

`js` 事件的判断属性名称，与真实使用的时候的名称不一定是一样的，所以使用的时候，还要需要稍微处理一下:
```js
let suitTransitionend = () => {
  let suitTransitionend = getTransitionend()
  if (suitTransitionend === 'ontransitionend') {
    suitTransitionend = 'transitionend'
  } else {
    suitTransitionend = suitTransitionend.slice(2, 3).toLowerCase() + suitTransitionend.slice(3)
  }
  return suitTransitionend
}

let suitTransitionend = setTransitionend()
document.body.addEventListener(suitTransitionend, ()=>{
    // ...
})
```

### 获取滚动条距离顶部的距离
```js
const getScrollTop = () => {
  return document.documentElement.scrollTop || document.body.scrollTop
}
```

### 获取当前可视范围的高度
```js
const getClientHeight = () => {
  let clientHeight = 0
  if (document.body.clientHeight && document.documentElement.clientHeight) {
    clientHeight = Math.min(document.body.clientHeight, document.documentElement.clientHeight)
  } else {
    clientHeight = Math.max(document.body.clientHeight, document.documentElement.clientHeight)
  }
  return clientHeight
}
```

### 获取文档完整的高度，包括超出屏幕可以滚动显示的部分
```js
const getScrollHeight = () => {
  return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
}
```

### 自定义 `jsonp`

```js
// 在页面中动态插入 script标签
const loadScript = (url, func, clear=false)=> {
  let script = document.createElement('script')
  let bodyEle = document.body
  script.src = url
  script.onload = script.onreadystatechange = function(){
    if(!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete') {
      func && typeof func === 'function' && func()
      clear ? bodyEle.removeChild(script) : (script.onload = script.onreadystatechange = null)
    }
  }
  bodyEle.appendChild(script)
}

// 自定义jsonp
const selfJsonp = (url, callback, cb='cb')=>{
  let cbname = cb + new Date().getTime()
  window[cbname] = (data)=>{
    callback(data)
    delete window[cbname]
  }
  url += url.indexOf('?') === -1 ? '?' : '&'
  url += (cb + '=' + cbname)
  loadScript(url, null, true)
}
```

### 页面链接跳转历史 `URL`不记录的兼容处理
同一个页面中链接的点击不记录 `history`
摘自 [张鑫旭](http://www.zhangxinxu.com/wordpress/2017/02/page-link-url-history-null-not-record/)

```js
var fnUrlReplace = function(eleLink) {
  if(!eleLink) return
  var href = eleLink.href
  if(href && /^#|javascript/.test(href) === false) {
    if(history.replaceState()) {
      history.replaceState(null, document.title, href.split('#')[0] + '#')
      location.replace('')
    } else {
      location.replace(href)
    }
  }
}
```

// 使用如下：
```js
document.querySelector('a').onclick = function(event) {
  if(event && event.preventDefault) {
    event.preventDefault()
  }
  fnUrlReplace(this)
  return false
}
```

### 将回调函数改成 `Promise`

```js
  /**
   * 将回调函数改成 promise
   * @param {function} fn (必) 执行的函数，比如 fs.readFile
   * @param {object} receiver 执行环境，比如 fs
   */
  // ES6
  const cb2Promise = (fn, receiver = null) => {
    return (...args) => {
      return new Promise((resolve, reject) => {
        fn.apply(receiver, [...args, (...cbData) => {
          if (cbData.length <= 1) {
            // 回调函数 cb的参数只有一个，说明只接收成功的回调，没有失败的回调
            return resolve(cbData)
          }
          // 回调函数 cb的第一个参数为失败的回调 err
          return cbData[0] ? reject(cbData[0]) : resolve(cbData[1])
        }])
      })
    }
  }

  // ES5
  var promisify = function promisify(fn, receiver) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return new Promise(function (resolve, reject) {
        fn.apply(receiver, [].concat(args, [function () {
          
          if (arguments.length <= 1) {
            // 回调函数 cb的参数只有一个，说明只接收成功的回调，没有失败的回调
            return resolve(arguments[0])
          } else {
            // 回调函数 cb的第一个参数为失败的回调 err
            return arguments[0] ? reject(arguments[0]) : resolve(arguments[1])
          }
        }]));
      });
    };
  };
```

### 获取元素距离页面顶部（不是浏览器顶部）的高度
```js
function getElementTop(elem){
　　var elemTop=elem.offsetTop;//获得elem元素距相对定位的父元素的top
　　elem=elem.offsetParent;//将elem换成起相对定位的父元素
　　while(elem!=null){//只要还有相对定位的父元素 
　　　　//获得父元素 距他父元素的top值,累加到结果中
　　　　elemTop+=elem.offsetTop;
　　　　//再次将elem换成他相对定位的父元素上;
　　　　elem=elem.offsetParent;
　　}
　　return elemTop;
}
```

### 根据 url 动态创建加载 JS脚本 - come from 《高性能网站建设进阶指南》

```js
var fnJsLoad = function(url, callback) {
  callback = callback || function(){}
  
  var eleScript = document.createElement('script')
  
  eleScript.onload = function() {
    // 防止多次创建
    if(!eleScript.isInited){
      eleScript.isInited = true
      callback()
    }
    
    // 低版本的 IE浏览器(IE9)使用这个函数加载
    eleScript.onreadystatechange = function() {
      if(!eleScript.isInited && /^loaded|complete$/) {
        eleScript.isInited = true
        callback()
      }
    }
    
    eleScript.src = url
    document.getElementsByTagName('head')[0].appendChild(eleScript)
  }
}

// 使用示例
fnJsLoad('https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js', function(){
  // JS 脚本加载完成后的操作
})
```

### 移动端浮层滚动的同时阻止背后 `document`的整个滚动
```css
/* CSS */
.noscroll, .noscroll body {
  overflow:hidden;
}
.noscroll body {
  position: relative;
}
```
```js
// 关键 JS代码, 非原生JS，基于 zepto 或者 jQuery实现
$.smartScroll = function(container, selectorScrollable) {
    // 如果没有滚动容器选择器，或者已经绑定了滚动事件，忽略
    if (!selectorScrollable || container.data('isBindScroll')) {
        return;
    }

    // 是否是矬浏览器
    // 自己在这里添加判断和筛选
    var isSBBrowser;

    var data = {
        posY: 0,
        maxscroll: 0
    };

    // 事件处理
    container.on({
        touchstart: function (event) {
            var events = event.touches[0] || event;
            
            // 先求得是不是滚动元素或者滚动元素的子元素
            var elTarget = $(event.target);
            
            if (!elTarget.length) {
                return;    
            }
            
            var elScroll;
            
            // 获取标记的滚动元素，自身或子元素皆可
            if (elTarget.is(selectorScrollable)) {
                elScroll = elTarget;
            } else if ((elScroll = elTarget.parents(selectorScrollable)).length == 0) {
                elScroll = null;
            }
            
            if (!elScroll) {
                return;
            }
            
            // 当前滚动元素标记
            data.elScroll = elScroll;
            
            // 垂直位置标记
            data.posY = events.pageY;
            data.scrollY = elScroll.scrollTop();
            // 是否可以滚动
            data.maxscroll = elScroll[0].scrollHeight - elScroll[0].clientHeight;
        },
        touchmove: function () {
            // 如果不足于滚动，则禁止触发整个窗体元素的滚动
            if (data.maxscroll <= 0 || isSBBrowser) {
                // 禁止滚动
                event.preventDefault();
            }
            // 滚动元素
            var elScroll = data.elScroll;
            // 当前的滚动高度
            var scrollTop = elScroll.scrollTop();
    
            // 现在移动的垂直位置，用来判断是往上移动还是往下
            var events = event.touches[0] || event;
            // 移动距离
            var distanceY = events.pageY - data.posY;
    
            if (isSBBrowser) {
                elScroll.scrollTop(data.scrollY - distanceY);
                elScroll.trigger('scroll');
                return;
            }
    
            // 上下边缘检测
            if (distanceY > 0 && scrollTop == 0) {
                // 往上滑，并且到头
                // 禁止滚动的默认行为
                event.preventDefault();
                return;
            }
    
            // 下边缘检测
            if (distanceY < 0 && (scrollTop + 1 >= data.maxscroll)) {
                // 往下滑，并且到头
                // 禁止滚动的默认行为
                event.preventDefault();
                return;
            }
        },
        touchend: function () {
            data.maxscroll = 0;
        }    
    });

    // 防止多次重复绑定
    container.data('isBindScroll', true);
};
```
