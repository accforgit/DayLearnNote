## 5 - 最长回文子串

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：
```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```
示例 2：
```
输入: "cbbd"
输出: "bb"
```

### 暴力破解

时间复杂度为 `O(n^3)`，空间复杂度为 `O(1)`

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
  let p = []
  let range = 1
  let m = 0
  let maxId = 0
  let id = 0
  let tempStr = ''
  let maxStr = ''
	// 将字符串转化为奇数长度获取到新的字符串
  var newStr = '#' + s.split('').join('#') + '#'
  var newLen = newStr.length
	// 时间复杂度为O(n)，空间复杂度为O(1)获取到所有的子回文的长度值组成的数组
  for (let i = 0; i < newLen; i++) {
    // maxId表示当前边界值最大的回文子串的边界值
    p[i] = maxId > i ? Math.min(p[2 * id - i], maxId - i) : 1
    range = p[i]
    tempStr = newStr[i]
    while (range-- > 1) {
      m = (tempStr.length - 1) / 2
      tempStr = tempStr.slice(0, m).concat(newStr[i - range], tempStr.slice(m, m + 1), newStr[i + range], tempStr.slice(m + 1))
    }
    // 超出其半径的位置再做额外判断
    while ((newStr[i + p[i]] === newStr[i - p[i]]) && newStr[i + p[i]]){
      tempStr = newStr[i + p[i]] + tempStr + newStr[i - p[i]]
      p[i]++
    }
    // 获取到边界最大的回文子串的中心位置以及边界值，以保证后续迭代可以做以上快捷处理
    if (i + p[i] > maxId) {
      id = i
      maxId = id + p[i]
    }
    if (tempStr.length > maxStr.length) {
      maxStr = tempStr
    }
    tempStr = ''
  }
	return maxStr.replace(/#/g, '')
};
```

### Manacher算法

参考文章：

- [JS 最长回文子串（包含动态规划以及Manacher算法）](https://www.cnblogs.com/mini-coconut/p/9074315.html)
- [C++ 求回文子串 O(n) manacher算法 ](https://wenku.baidu.com/view/3031d2d3360cba1aa811da42.html)

时间复杂度为 `O(n)`
```js
var longestPalindrome = function(s) {
  // p[i] 表示以下标为 i 的字符为中心字符的回文子串的回文半径长度（相对于新串）
  let p = []
  // 表示当前边界值最大的回文子串的边界值（即当前已经取得的所有回文子串中所包含的所有字符中，最大的下标）（相对于新串）
  let maxIndex = 0
  // 边界最大的回文子串的中心位置（相对于新串）
  let id = 0
  // 最大的回文子串的中心位置的下标（相对于新串）
  let middleIndex = 0
  // 最大的回文子串的长度（相对于新串）
  let maxLen = 0
	// 将字符串转化为奇数长度获取到新的字符串
  let newStr = '#' + s.split('').join('#') + '#'
  const newLen = newStr.length
	// 时间复杂度为O(n)，空间复杂度为O(1)获取到所有的子回文的长度值组成的数组
  for (let i = 0; i < newLen; i++) {
    p[i] = maxIndex > i ? Math.min(p[2 * id - i], maxIndex - i) : 1
    // 超出其半径的位置再做额外判断
    while ((newStr[i + p[i]] === newStr[i - p[i]]) && newStr[i + p[i]]){
      p[i]++
    }
    // 获取到边界最大的回文子串的中心位置以及边界值，以保证后续迭代可以做以上快捷处理
    if (i + p[i] > maxIndex) {
      id = i
      maxIndex = id + p[i]
    }
    if (p[i] > maxLen) {
      middleIndex = i
      maxLen = p[i]
    }
  }
  return s.substr((middleIndex + 1 - maxLen) / 2, maxLen - 1)
};
```

## 6 - Z 字形变换

将一个给定字符串根据给定的行数，以从上往下、从左到右进行 `Z` 字形排列。

比如输入字符串为 `LEETCODEISHIRING` 行数为 `3` 时，排列如下：
```
L   C   I   R
E T O E S I I G
E   D   H   N
```
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`LCIRETOESIIGEDHN`。

请你实现这个将字符串进行指定行数变换的函数：
```c++
string convert(string s, int numRows);
```
示例 1:
```
输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
```
示例 2:
```
输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
```
解释:
```
L     D     R
E   O E   I I
E C   I H   N
T     S     G
```

参考文章：

- [Z字形变换算法分析及优化（O(k*n)到O(n)）](https://blog.csdn.net/qq_28114615/article/details/84898070)

### 暴力破解

```js
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
  const len = s.length
  const markNum = 2 * numRows - 2
  let res = ''
  if (markNum === 0) return s
  for (let i = 0; i < numRows; i++) {
    for (let j = 0; j < len; j++) {
      if ((i + j) % markNum ===0 || (j - i) % markNum === 0) {
        res += s[j]
      }
    }
  }
  return res
}
```

### 步进优化

```js
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
  const len = s.length
  const markNum = 2 * numRows - 2
  let res = ''
  let mIndex = 0
  if (markNum === 0) return s
  for (let i = 0; i < numRows; i++) {
    for (let j = i; j < len; j+=markNum) {
      res += s[j]
      mIndex = j + markNum - 2 * (j % markNum)
      if (mIndex !== j && mIndex < len && mIndex % markNum) {
        res += s[mIndex]
      }
    }
  }
  return res
};
```

## 7 - 整数反转

给出一个 `32` 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

示例 1:
```
输入: 123
输出: 321
```

示例 2:
```
输入: -123
输出: -321
```

示例 3:
```s
输入: 120
输出: 21
```

注意:

假设我们的环境只能存储得下 `32` 位的有符号整数，则其数值范围为 `[−231,  231 − 1]`。请根据这个假设，如果反转后整数溢出那么就返回 `0`。

```js
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
    let res = Array.from(x+'');
     
    if(res[0] !== '-'){
        let num = parseInt(res.reverse().join(''),10);
         if( num> Math.pow(2,31) -1){
             return 0
         }
       return num; 
    }else{
        res.reverse().pop();
      let num = parseInt(res.join(''),10);
        if( num> Math.pow(2,31) -1){
             return 0
         }
        return  '-' + num; 
    }
};
```

## 8 - 字符串转换整数 (atoi)

请你来实现一个 `atoi` 函数，使其能将字符串转换成整数。

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 `0`。

说明：

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，qing返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

示例 1:
```
输入: "42"
输出: 42
```
示例 2:
```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```
示例 3:
```
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```
示例 4:
```
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
```
示例 5:
```
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
```
```js
/**
 * @param {string} str
 * @return {number}
 */
const INT_MAX=Math.pow(2,31)-1;
const INT_MIN=Math.pow(-2,31);
var myAtoi = function(str) {
  let newStr = str.trim()
  if (!/[\d|+|-]/.test(newStr[0])) return 0
  const v = newStr.match(/^[\d|+|-]\d*/)[0]
  if (v.length === 1 && (v === '+' || v === '-')) return 0
  if (v<INT_MIN) {
      return INT_MIN
  } else if (v>INT_MAX) {
      return INT_MAX
  }
  return +v
};
```

## 9 - 回文数

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

示例 1:
```
输入: 121
输出: true
```
示例 2:
```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```
示例 3:
```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```

```js
/**
 * @param {number} x
 * @return {boolean}
 */
var isPalindrome = function(x) {
 if (x < 0 || (x % 10 === 0 && x !== 0)) return false
  let reverseNum = 0
  while (x > reverseNum) {
    reverseNum = reverseNum * 10 + x % 10
    x = Math.floor(x/10)
  }
  return x === reverseNum || x === Math.floor(reverseNum / 10)
};
```